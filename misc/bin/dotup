#!/usr/bin/env bash

##--> A script to update the dotfiles <--##
# URL - https://github.com/adityastomar67/dots

# Set the path to your dotfiles directory
DOTFILES_DIR="$HOME/dotfiles"

clear
removeOrStash() {
    local text="${1:?}"
    printf "${text}"
    select opt in "Remove" "Persist"; do
        if [ $opt ]; then
            break
        fi
    done
    clear
    if [ $opt = "Remove" ]; then
        printf "$(tput setaf 1)❌ Removing the changes...$(tput sgr0)\n"
        sleep 2
        git reset --hard
        printf "\n$(tput setaf 3)→ Updating the configuration...$(tput sgr0)\n"
        sleep 1
        git pull

    else
        printf "$(tput setaf 3)→ Updating the configuration...$(tput sgr0)\n"
        git stash >/dev/null 2>&1
        git pull
        git stash apply >/dev/null 2>&1
    fi

    unset opt
}

nvimUpdate() {
    clear
    echo "Do you want to update Neovim also?"
    select option in "Yes" "No"; do
        if [ $option ]; then
            break
        fi
    done

    if [ $option = "Yes" ]; then
        cd $HOME/.config/nvim
        removeOrStash "\n\nChoose whether you want to reset the Neovim options or persist them over the update?..\n"
        printf "\n$(tput setaf 2)$(tput bold)✓ Successfully Updated Neovim.$(tput sgr0)\n"
        sleep 2
    fi

    unset option
}

if [ $# -gt 0 ]; then
    case "$1" in
    -n | --nvim)
        if [ -d $HOME/.config/nvim ]; then
            printf "$(tput bold)Updating Neovim...$(tput sgr0)"
            sleep 2
            cd $HOME/.config/nvim
            removeOrStash "\n\nChoose whether you want to reset the Neovim options or persist them over the update?..\n"
            printf "\n$(tput setaf 2)$(tput bold)✓ Successfully Updated Neovim.$(tput sgr0)\n"
            sleep 2
            cd $HOME
            exit 1
        else
            printf "$(tput setaf 1)❌ Neovim Configurations doesn't exists!$(tput sgr0)\n"
            clear
            exit 1
        fi
        ;;
    ?)
        # echo "script usage: $(basename \$0) [-l] [-h] [-a somevalue]" >&2
        exit 1
        ;;
    esac
else
    printf "$(tput bold)Updating the config...$(tput sgr0)\n\n"
    sleep 1

    ##--> Updating dotfiles <--##
    [ -d $DOTFILES_DIR ] && cd $DOTFILES_DIR
    removeOrStash "Choose whether you want to reset the changes or persist them over the update?..\n"
    printf "\n$(tput setaf 2)$(tput bold)✓ Successfully Updated the Dotfiles.$(tput sgr0)\n"
    sleep 3

    ##--> Updating Neovim <--##
    [ -d $HOME/.config/nvim ] && nvimUpdate

    ##--> Reloading the BSPWM and keybindings, st also <--##
    clear
    printf "$(tput bold)Reloading BSPWM, SXHKD and Suckless tools...$(tput sgr0)\n"
    sleep 2
    bspc wm -r; sleep 2; dunstify -u low -i ~/.config/bspwm/assets/reload.svg 'Bspwm' 'The BSPWM has been reloaded successfully!'
    pkill -USR1 -x sxhkd >/dev/null 2>&1; dunstify -u low -i ~/.config/bspwm/assets/reload.svg 'Sxhkd' 'The keybindings has been reloaded successfully!'
    sleep 2
    xrdb merge "$HOME/.config/bspwm/rices/$RICETHEME/xresources" && kill -USR1 $(pidof st) >/dev/null 2>&1; \
        dunstify -u low -i ~/.config/bspwm/assets/reload.svg 'ST Terminal' 'The terminal has been reloaded successfully!'

    ##--> Finishing <--##
    clear
    printf "$(tput bold)Sourcing zsh...$(tput sgr0)"
    sleep 2
    cd $HOME
    zsh
fi













# Set the name of the remote and branch you want to track
REMOTE_NAME="origin"
BRANCH_NAME="master"

# Set any additional options you want to pass to git pull
GIT_PULL_OPTIONS=""

# Set any post-update commands you want to run
POST_UPDATE_COMMANDS=""

# Change to the dotfiles directory
cd $DOTFILES_DIR

# Check for command line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -r | --reset)
        echo "Resetting all changes to the latest commit..."
        git fetch $REMOTE_NAME $BRANCH_NAME
        git reset --hard $REMOTE_NAME/$BRANCH_NAME
        exit 0
        ;;
    *)
        echo "Invalid option: $key"
        exit 1
        ;;
    esac
    shift
done

# Check if there are any uncommitted changes
if ! git diff-index --quiet HEAD --; then
    echo "There are uncommitted changes in the local repository. Stashing changes..."
    git stash push --include-untracked --message "Stashing changes for dotfile update"
    CHANGES_STASHED=true
fi

# Check if there are any changes in the remote repository
if git fetch $REMOTE_NAME $BRANCH_NAME | grep -q 'up to date'; then
    echo "No updates found in the remote repository."
    if [[ $CHANGES_STASHED == true ]]; then
        echo "Restoring stashed changes..."
        git stash apply --index
        git stash drop
    fi
    exit 0
fi

# Apply the stashed changes
echo "Applying stashed changes..."
if ! git stash apply --index; then
    echo "Merge conflicts detected. Resolving conflicts with vimdiff..."
    git mergetool -t vimdiff
    git add .
    git stash drop
fi

# Update the dotfiles
# This is where you would put any commands to update your dotfiles
# For example, you might run a script that symlinks your dotfiles to your home directory
# or updates your system configurations
echo "Updating dotfiles..."

# Run any post-update commands
# For example, you might restart any services that depend on the updated dotfiles
if [[ -n "$POST_UPDATE_COMMANDS" ]]; then
    echo "Running post-update commands..."
    eval $POST_UPDATE_COMMANDS
fi

# Commit the updated dotfiles
echo "Committing changes..."
git commit -m "Updated dotfiles"

# Check if there are any stashed changes remaining
if [[ $CHANGES_STASHED == true ]]; then
    echo "Restoring remaining stashed changes..."
    git stash apply
    git stash drop
fi

# Push the changes to the remote repository
echo "Pushing changes to remote repository..."
git push $REMOTE_NAME $BRANCH_NAME

echo "Update complete."
